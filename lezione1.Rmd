---
title: "Intro a R"
author: "Paolo Bosetti"
date: "2025-10-02"
output:
  html_notebook:
    toc: true
    number_sections: true
  word_document:
    toc: true
    number_sections: true
  html_document:
    toc: true
    number_sections: true
---

# Prima lezione: Markdown

Un carattere # all'inizio di una riga, senza spazi prima e con almeno uno spazio dopo, indica un titolo di sezione.

Questo è un testo di paragrafo. Un paragrafo deve iniziare sempre dal primo carattere (NO INDENTAZIONI!) e deve essere separato da linee vuote. 

Una linea vuota equivale ad un a-capo, quindi paragrafi diversi devono essere separati da una (o più) linee vuote.

## Formattazione in linea

Due caratteri ## indicano un titolo di livello due, tre caratteri ### un titolo di livello tre, e così via.

Questo è un **testo in grassetto** e questo *è in corsivo*. Il codice viene in genere visualizzato con carattere *monospaziato* (cioè in cui tutti i caratteri hanno la stessa larghezza), e si ottiene con gli apici inversi, così: `function()`.

## Elenchi

Un elenco puntato:

* questo
* è un esempio
* di elenco puntato
  - anche con sotto-elenchi
  - come questo
* e questo è l'ultimo punto.

È obligatorio inserire una riga vuota prima e dopo l'elenco. Inoltre il primo livello deve iniziare all'inizio della riga (no spazi prima di `*`).

Elenco numerato:

1.  primo
2.  secondo
3.  terzo

Valgono le stesse regole che per l'elenco numerato. Nota che i numeri non devono essere necessariamente in sequenza: le voci vengono rinumerate automaticamente in generazione del documento.


# Inserimento di blocchi R

I notebook consentono di generare documenti di qualità alternando testo descrittivo e codice utilizzato per l'analisi. Il codice viene inserito come *chunk*, mediante l'icona verde con la `c` in alto, oppure con la scorciatoia Ctrl-Alt-i (Windows e Linux) o Cmd-Opt-i (MacOS).

In fase di generazione del documento, il *chunk* viene valutato e, se genera output testuale o grafico, questo viene inserito immediatamente sotto il codice.

```{r echo=TRUE}
df <- expand.grid(
  N = 1:2,
  A = c(1, 6, 10),
  B = LETTERS[1:3]
)
df
```

## Differenza tra *Preview Notebook* e *Knit to HTML*

Il comando *Preview Notebook* genera una preview del documento utilizzando le valutazioni dei vari blocchi effettuate mano a mano dall'utente mentre scrive il documento. Queste valutazioni modificano il contesto, o *ambiente*, dell'interprete R principale, quello della console. La generazione dell'output è quindi molto rapida (perché il codice è già stato valutato), ma è necessario prestare attenzione che tutti i *chunk* siano valutati correttamente e nell'ordine giusto. In particolare, se un determinato *chink* non è mai stato valutato nella corrente sessione di RStudio, nessun output verrà inserito nella preview. Ogni tanto, è bene cioè scegliere *Run All* dal menu del documento *Run*, per assicurarsi che tutti i blocchi siano eseguiti e nella sequenza corretta.

Il comando *Knit to HTML* (e tutti gli altri comandi *Knit to ...*), invece, **esegue tutti i blocchi in un interprete separato**. Ciò assicura che il risultato finale sia attendibile e corretto, ma può richiedere molto tempo nel caso di documenti molto lunghi e con molti calcoli. L'ambiente in cui vengono create variabili e oggetti viene creato all'inizio dell'operazione e distrutto alla fine, e non è visibile all'utente.

Per questo motivo, soprattutto su computer più lenti, è consigliato utilizzare la semplice *preview* durante la preparazione del documento, e limitarsi a generare il documento finale con *knit* solo nella fase finale.


# Equazioni in $\LaTeX$

In breve, le equazioni in $\LaTeX$ possono essere inserite sia in linea, come questa: $a=b+c$, che separatemente dal testo, in questo modo:

$$
a = b + c
$$
I quozienti si inseriscono come `\frac{numeratore}{denominatore}`:

$$
a = \frac{1}{b+c}
$$

Gli apici e i pedici si creano con `^` e `_`, rispettivamente. Se in apice o pedice c'è più di un carattere, questi vanno circondati da graffe:

$$
x_{ij} = \mu + \tau_i + \epsilon_{ij} 
$$
Come si vede, le lettere greche si ottengono anteponendo `\` al nome della lettera. Si noti che per la lettera epsilon esistono due varianti tipografiche: $\epsilon$ (`\epsilon`) e $\varepsilon$ (`\varepsilon`); per i indicare i residui si preferisce di solito la seconda.

Le sommatorie e gli integrali si ottengono con `\sum` e `\int`, rispettivamente:

$$
\bar x = \frac{1}{N} \sum_{i=1}^N x_i
$$
e:

$$
f^-(x) = \int_{-\infty}^x f(\xi) d\xi;~~~f^+(x) = \int_x^{+\infty} f(\xi) d\xi
$$
Si noti che il carattere `~` indica uno spazio.

Per ottenere più equazioni allineate in un blocco si usa l'ambiente `align` (si noti che in questo caso non servono i marcatori `$`):

\begin{align}
f^-(x) &= \int_{-\infty}^x f(\xi) d\xi \\
f^+(x) &= \int_x^{+\infty} f(\xi) d\xi;
\end{align}

Dove ogni linea eccetto l'ultima deve terminare con un doppio *backslash* e il carattere `&` indica il punto di allineamento.

Infine, i nomi delle funzioni più comuni (trigonometriche, esponenziali, ...) devono essere preceduti da una backslash, perché scrivere $\sin(x)$ non è come scrivere $sin(x)$ (quest'ultimo è il prodotto delle quattro variabili $s$, $i$, $n$ e $x$).


# Statistica descrittiva

## Statistiche: media e varianza

Le funzioni `mean`, `var` e `sd` forniscono la media, la varianza e la deviazione standard, rispettivamente, di un vettore passato come argomento.

```{r}
# Questo è un commento
v <- c(10, 14, 12, 9, 7)
mean(v) # Media di v
var(v)  # Varianza di v
sd(v)   # Deviazione standard di v
sd(v)^2
```

Se il vettore contiene uno o più `NA`, le funzioni statistiche restituiscono `NA`, **a meno che** non si specifichi di rimuovere i valori mancanti con l'opzione `na.rm = TRUE`:

```{r}
(v <- c(v, 13, NA))
v.m <- mean(v, na.rm=TRUE)
```

È anche possibile valutare un'espressione R in linea: la media del vettore `v` è `r round(v.m, 3)`. Notare che scrivere `un testo tra backtick` è una semplice formattazione in carattere monospaziato (adatta per il codice: funzioni o nomi di variabili). Se invece dopo il primo backtick si inserisce una `r` seguita da uno spazio, quanto segue verrà valutato come espressione R e il risultato verrà restituito in linea. La funzione `round()` serve per **arrotondare** un valore ad una certa cifra decimale.

Altre operazioni utili:

```{r}
sum(v, na.rm=T)
median(v, na.rm=T)
sum(v, na.rm=T)/length(v) # Attenzione: length conta anche i NA!
```

È possibile **filtrare** il vettore `v` in modo da rimuovere tutti i valori `NA` usando l'**indicizzazione logica** e la funzione `is.na()`:

```{r}
v1 <- v[!is.na(v)]
sum(v1) / length(v1)
mean(v1)
```

## Distribuzioni

In R ci sono numerose funzioni per trattare diverse distribuzioni come:

* `binom`: binomiale
* `pois`
* `geom`
* `unif`
* `norm`
* `chisq`
* `t`
* `f`

A questi nomi di distribuzioni vanno prefisse le lettere:

* `r`: per generare numeri random presi da una specifica distribuzione
* `d`: per la PDF
* `p`: per la probabilità, cioè la CDF
* `q`: per la funzione quantile (inversa della CDF)

Le funzioni di distribuzione si ottengono quindi combinando l'opportuno prefisso con il nome breve della distribuzione. Ad esempio, `qnorm()` è la funzione quantile della distribuzione normale.

La **generazione di numeri casuali** si ottiene con le funzioni `r*`. Si tratta in realtà di numeri *pseudo-casuali*, la cui sequenza può essere resa ripetibile impostando forzatamente un seme specifico mediante la funzione `set.seed()`:

```{r}
set.seed(0)
rnorm(10) # Normale standard
rgeom(10, 0.1) # geometrica con probabilità 0.1
```

## Grafici

Il modo più semplice di creare un grafico con **R base** è mediante la funzione `plot`:

```{r}
s <- rchisq(100, 10)
plot(s)
```
Più avanti utilizzeremo esclusivamente la nuova interfaccia Tidyverse, ma per il momento `plot` è più semplice.

Per aggiungere una seconda serie ad un primo grafico si utilizza la funzione `points` o `lines`. Si noti che i limiti del grafico vengono definiti dalla prima chiamata a `plot` e **non vengono modificati** dalle successive serie. Se essi sono troppo stretti, possono essere modificati con il parametro `ylim` (e `xlim`) di `plot`:

```{r}
x <- 1:10
y <- x^2
y2 <-  2 + 10 * x + x^2
plot(x, y, type = "b", col="red", ylim=c(0,200), xlim=c(-5, 15))
lines(x, y2, col="blue", type="b")
# points()
```

Otteniamo ora il grafico della PDF normale. La funzione `grid` aggiunge una griglia all'ultimo grafico:

```{r}
x <- seq(-3, 3, 0.1)
y <- dnorm(x)
plot(x, y, type="l", xlab="x", ylab="Densità di probabilità")
grid()
```

Confrontiamo la T di Student per diversi gradi di libertà con la normale standard: come anticipato la differenza tra le due diminuisce molto rapidamente all'aumentare del numero di gradi di libertà della T, già a 50 è praticamente trascurabile:

```{r}
plot(x, y, type="l")
lines(x, dt(x, 5), col="red")
lines(x, dt(x, 10), col="green")
lines(x, dt(x, 50), col="orange")
lines(x, dt(x, 5E6), col="blue")
```

## Istogrammi

Gli istogrammi si ottengono passando il solo vettore alla funzione `hist`. Si noti che di default in ordinata si ha il **conteggio** delle osservazioni. Per un confronto con la PDF della distribuzione è necessario specificare che si desidera la densità di osservazioni sull'asse ordinato, cioè il conteggio diviso per il totale delle osservazioni (opzione `freq=FALSE`):

```{r}
set.seed(0)
v <- rnorm(1000)
hist(v, freq=F, breaks="Sturges")
lines(x, dnorm(x))
```


## Cumulata

La funzione di ripartizione, o cumulata, rappresenta l'integrale progressivo della PDF. Si può specificare la coda desiderata (alta o bassa) mediante l'opzione `lower.tail`:

```{r}
plot(x, pnorm(x, lower.tail=F), type="l")
lines(x, pnorm(x), col="red")
```
Il confronto con una distribuzione di riferimento può essere effettuato anche con la cumulata, usando la funzione `ecdf()`, cioè *Empirical Cumulated Distribution Function* (cumulata empirica), l'equivalente campionario della CDF. Si noti che la `ecdf()` **restituisce una funzione**, che può quindi essere valutata su diversi valori (o su un vettore) di `x`.

```{r}
v.ecdf <- ecdf(v)
v.ecdf(2)
```
```{r}
plot(x, pnorm(x), type="l")
lines(x, v.ecdf(x), col="red")
```

**Esercizio**: provare a confrontare la `ecdf` di un campione non-normale (ad es, tratto dalla T di Student) con la CDF teorica normale standard, e commentare la differenza.


## Quantili

È spesso utile calcolare i quantili di un campione:

```{r}
quantile(v)
min(v)
max(v)
median(v)
```

Per default, `quantile` restituisce i quartili. Con l'opzione `probs` si può però valutare una quasiasi sequenza di probabilità:

```{r}
quantile(v, probs=c(0, 1/3, 2/3, 1))
quantile(v, probs=seq(0, 1, 0.1))
quantile(v, probs=seq(0, 1, length.out=6))
quantile(v, 0.28)
```

Possiamo aggiungere quantili e relative probabilità alla cumulata del campione:

```{r}
probs <- seq(0, 1, length.out=5)
plot(ecdf(v))
lines(x, pnorm(x), col="red")
abline(h=probs, lty=2)
abline(v=quantile(v, probs=probs), lty=2)
```

Infine, la **funzione quantile** della distribuzione normale si ottiene con `qnorm()` (specificando se serve la coda con `lower.tail`).

```{r}
x <- seq(0, 1, length.out=1000)
plot(x, qnorm(x), type="l")
```

**Esercizio**: provare a confrontare il quantile empirico e il quantile teorico, analogamente a quanto fatto con la `ecdf()`.


# Data frame

Uno dei modi più efficaci di raccogliere dati è il **data frame**: si tratta di una tabella con colonne nominate e potenzialmente eterogenee:

```{r}
N <- 200
df <- data.frame(
  x = seq(-3, 3, length.out=N),
  y = rnorm(N),
  y2 = rnorm(N, 1, 0.5)
)
```

Per analizzare rapidamente una data frame sono utili la funzione `str()`, che ne riporta la **strutura**, e la funzione `summary()`, che ne riporta i quantili:

```{r}
str(df)
summary(df)
```

È facile aggiungere una nuova colonna, a patto che il vettore che si aggiunge **abbia la stessa lunghezza** delle colonne già presenti:

```{r}
df$y3 <- runif(N)
str(df)
```

Raccogliere i dati in data frame anziché in vettori consente di utilizzare, ad esempio, le funzioni di plot secondo una sintassi più efficiente:

```{r}
plot(df$y ~ df$x)
```

Ma siccome `df$` è ripetuto, può essere fattorizzato nell'opzione `data`:

```{r}
plot(y~x, data=df, type="l")
```

Cioè: "plotta `y` in funzione di `x` prendendo le colonne dal data frame `data`". La notazione `y~x` si chiama **formula**.
